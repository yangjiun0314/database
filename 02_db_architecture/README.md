# Week 02 — DB 시스템 아키텍처 & 데이터 모델 (롱폼)

> 이번 주는 **DB 접근의 핵심 특성(자기 서술성·다중 뷰·프로그램–데이터 분리·트랜잭션)**, **3계층(외부/개념/내부)과 데이터 독립성**, **데이터 모델·스키마/인스턴스**, **DBMS 언어(DDL/VDL/SDL/DML)**, **DB 사용자/인터페이스**까지 한 번에 묶어 큰 그림을 잡는다.

---

## 0) 큰 그림: “왜 DBMS인가”
- 하나의 저장소(카탈로그 포함)에서 다양한 사용자가 같은 데이터를 **일관되게 공유**하고, 다수 사용자가 동시에 접근해도 **트랜잭션 특성(원자성·고립성 등)**으로 안전하게 처리한다.
- 전통적 파일 처리와 달리 **데이터 정의가 카탈로그에 분리 저장**되어, 응용을 바꿔도 구조를 재컴파일할 필요가 없도록 설계한다(자기 서술성).

---

## 1) 3계층(Three-Schema) 아키텍처
**목표**: 사용자/응용 ↔ 물리 저장을 “느슨하게 결합”해 변경에 강한 시스템을 만든다.

External Views (개별 사용자/팀 뷰들)
│ (external ↔ conceptual mapping)
Conceptual Schema (조직 전체 논리 구조: 엔터티/관계/제약/연산)
│ (conceptual ↔ internal mapping)
Internal Schema (물리 구조: 파일조직·페이지·인덱스 등)
Stored Database
- **외부(External)**: 역할/사용자별 **부분 뷰**(보고 싶은 것만 본다).
- **개념(Conceptual)**: 조직 전체의 공식 **논리 스키마**(엔터티·관계·제약·연산).
- **내부(Internal)**: 디스크 상 **물리 저장 구조**(파일조직, 페이지, 인덱스).
- **사상(Mapping)**: 요청/결과를 계층 사이에서 **변환**한다(필수지만 오버헤드가 있을 수 있음).

### 데이터 독립성 (핵심!)
- **물리적 독립성**: 내부(인덱스 추가, 파일조직 변경)를 바꿔도 개념/외부는 그대로.
- **논리적 독립성**: 개념(속성 추가·삭제·제약 변경)이 바뀌어도 외부/응용 영향 최소.
- 실전 비유
  - 물리적: 조회 속도 개선 위해 `SECTION(semester, year)`에 인덱스 추가해도 기존 질의 코드는 그대로.
  - 논리적: `STUDENT`에 `DateOfBirth` 속성을 추가해도, DOB를 보지 않는 기존 뷰/프로그램은 영향 없음.

---

## 2) 데이터 모델 · 스키마 · 인스턴스
- **데이터 모델**: 데이터 타입·관계·제약 + 기본 연산의 집합.
  - **고수준/개념**: 엔터티/관계 중심(ER 등).
  - **저수준/물리**: 저장 구조·접근 경로 기술.
  - **표현/구현(Representational)**: 논리적 표현과 물리 사이(레코드 기반·관계형/SQL 등).
- **스키마(내포, Intension)**: 구조 정의(자주 안 바뀜).
- **인스턴스/상태(외연, Extension)**: 특정 시점의 실제 데이터(갱신 때마다 바뀜).
- **스키마 진화(schema evolution)**: 운영 중에도 일부 DBMS는 제한적 스키마 변경을 지원.

---

## 3) DBMS 언어 & 인터페이스
- **DDL**: (보통) 개념 스키마 정의. **VDL**(뷰 정의어), **SDL**(저장 정의어)을 분리하는 시스템도 있으나, 실제로는 DDL이 외부/개념을 함께 다루는 경우가 많다.
- **DML**: 조회/삽입/수정/삭제.
  - **고수준(선언형, set-at-a-time)**: SQL처럼 한 문장으로 집합 처리.
  - **저수준(절차적, record-at-a-time)**: 레코드 단위 접근(루프 필요).
- **데이터 부속어**: DML이 C/Java 같은 호스트 언어에 **임베드**될 때의 개념.
- **사용자 인터페이스**: 메뉴 기반, 폼 기반(파라메트릭 사용자), 질의 에디터(캐주얼 사용자) 등.

---

## 4) 사용자/역할(Actors)
- **DBA**: 권한·보안, 백업/회복, 성능·자원 관리, 정책/표준 수립.
- **Database Designer**: 저장할 데이터 식별, 스키마 설계, 사용자 요구 통합.
- **End Users**
  - **Naive/Parametric**: 정해진 폼/트랜잭션 반복(창구직원, 예약시스템 등).
  - **Casual**: 애드혹 질의(중간관리자 등).
  - **Sophisticated**: 분석가/엔지니어(복잡 질의/툴 능숙).
  - **Stand-alone**: 패키지 소프트웨어 사용자(개인 DB).
- **응용 프로그래머**, **도구/유틸리티 개발자**, **운영 인력**.

---

## 5) DBMS의 장점과 주의할 점
- 장점: **자기 서술성(카탈로그)**, **프로그램–데이터 분리**, **다중 뷰**, **동시성/회복/보안**, **무결성·트리거**, **표준화·유지보수 용이성**, **스키마 변경 유연성**, **규모의 경제**.
- 주의(“안 써도 되는” 경우):
  - 요구가 **단순·고정**이고 변화가 거의 없음.
  - **엄격한 실시간** 제약 때문에 DBMS 오버헤드가 부담.
  - **단일 사용자**만 접근.

---

## 6) (요약) 시험·과제서 자주 나오는 포인트
- “**스키마 vs 인스턴스**”를 구분할 것.
- **물리/논리적 독립성**의 예시를 문장으로 말할 수 있을 것.
- **DDL/VDL/SDL/DML**의 역할과 오늘날 SQL의 위치(DDL+VDL+DML 통합)를 설명할 수 있을 것.
- **고수준 DML(선언형)** vs **저수준 DML(절차적)** 차이를 예로 들 수 있을 것.
- **DBA/Designer/End Users** 역할 구분.

---

## 7) 셀프 체크(짧게 서술)
1) 외부/개념/내부를 한 줄씩 정의하고, 물리적 vs 논리적 독립성 차이를 **예시**로 들어라.  
2) DDL·VDL·SDL·DML을 오늘날 SQL 관점에서 어떻게 이해하면 좋은가?  
3) DBMS가 과할 수 있는 사례 2가지를 쓰고 이유를 붙여라.  

---